/*
 * Copyright (c) 2020 Â· Marton Lederer
 * This file was created / generated by Marton Lederer
 * See the LICENSE on the github repo
 * https://github.com/MartonDev
 * https://marton.lederer.hu
 */

import { fromUint8Array } from '../deps.ts'

const HEADER = '\x89PNG\r\n\x1A\n'

// crc32 lookup
const crc32: Array<number> = []

for(let i = 0; i < 256; i++) {

  let c = i

  for(let j = 0; j < 8; j++) {

    if(c & 1) {

      c = -306674912 ^ ((c >> 1) & 0x7fffffff)

    }else {

      c = (c >> 1) & 0x7fffffff

    }

  }

  crc32[i] = c;

}

//searching in crc32
function lookUpcrc32 (buffer: Uint8Array, offset: number, size: number): void {

  let crc = -1

  for(let i = 4; i < size - 4; i++)
    crc = crc32[(crc ^ buffer[offset + i]) & 0xff] ^ ((crc >> 8) & 0x00ffffff)

  write4(buffer, offset + size - 4, crc ^ -1);

}

//writing
function write4 (buffer: Uint8Array, offset: number, value: number): number {

  buffer[offset++] = (value >> 24) & 255
  buffer[offset++] = (value >> 16) & 255
  buffer[offset++] = (value >> 8) & 255
  buffer[offset++] = value & 255

  return offset

}

function write2 (buffer: Uint8Array, offset: number, value: number): number {

  buffer[offset++] = (value >> 8) & 255
  buffer[offset++] = value & 255

  return offset

}

function write2lsb (buffer: Uint8Array, offset: number, value: number): number {

  buffer[offset++] = value & 255
  buffer[offset++] = (value >> 8) & 255

  return offset

}

function writeString (buffer: Uint8Array, offset: number, string: string): number {

  for(let i = 0, n = string.length; i < n; i++)
    buffer[offset++] = string.charCodeAt(i)

  return offset

}

interface Palette {

  [key: string]: number

}

//creating the image here
export class PNGImage {

  private readonly width: number
  private height: number
  private readonly depth: number

  private readonly bit_depth: number
  private readonly pix_format: number
  private readonly pix_size: number

  private readonly data_size: number

  private readonly ihdr_offs: number
  private readonly ihdr_size: number
  private readonly plte_offs: number
  private readonly plte_size: number
  private readonly trns_offs: number
  private readonly trns_size: number
  private readonly idat_offs: number
  private readonly idat_size: number
  private readonly iend_offs: number
  private readonly iend_size: number
  private readonly buffer_size: number

  private readonly buffer: Uint8Array
  private palette: Palette
  private pindex: number
  private backgroundColor: Object

  constructor (width: number, height: number, depth: number, backgroundColor: Object = { r: 0, g: 0, b: 0, a: 0 }) {

    this.width = width
    this.height = height
    this.depth = depth

    this.bit_depth = 8
    this.pix_format = 3
    this.pix_size = height * (width + 1)

    this.data_size = 2 + this.pix_size + 5 * Math.floor((0xfffe + this.pix_size) / 0xffff) + 4

    this.ihdr_offs = 0
    this.ihdr_size = 4 + 4 + 13 + 4
    this.plte_offs = this.ihdr_offs + this.ihdr_size
    this.plte_size = 4 + 4 + 3 * depth + 4
    this.trns_offs = this.plte_offs + this.plte_size
    this.trns_size = 4 + 4 + depth + 4
    this.idat_offs = this.trns_offs + this.trns_size
    this.idat_size = 4 + 4 + this.data_size + 4
    this.iend_offs = this.idat_offs + this.idat_size
    this.iend_size = 4 + 4 + 4
    this.buffer_size  = this.iend_offs + this.iend_size

    const rawBuffer = new ArrayBuffer(HEADER.length + this.buffer_size)

    writeString(new Uint8Array(rawBuffer), 0, HEADER)

    const buffer = new Uint8Array(rawBuffer, HEADER.length, this.buffer_size)

    this.palette = {}
    this.buffer = buffer
    this.pindex = 0

    let off = write4(buffer, this.ihdr_offs, this.ihdr_size - 12)
    off = writeString(buffer, off, 'IHDR')
    off = write4(buffer, off, width)
    off = write4(buffer, off, height)
    buffer[off++] = this.bit_depth
    buffer[off++] = this.pix_format
    off = write4(buffer, this.plte_offs, this.plte_size - 12)
    writeString(buffer, off, 'PLTE')
    off = write4(buffer, this.trns_offs, this.trns_size - 12)
    writeString(buffer, off, 'tRNS')
    off = write4(buffer, this.idat_offs, this.idat_size - 12)
    writeString(buffer, off, 'IDAT')
    off = write4(buffer, this.iend_offs, this.iend_size - 12)
    writeString(buffer, off, 'IEND')

    let header = ((8 + (7 << 4)) << 8) | (3 << 6)
    header += 31 - (header % 31)

    write2(buffer, this.idat_offs + 8, header)

    for(let i = 0; (i << 16) - 1 < this.pix_size; i++) {

      let size, bits

      if(i + 0xffff < this.pix_size) {

        size = 0xffff
        bits = 0

      }else {

        size = this.pix_size - (i << 16) - i
        bits = 1

      }

      let off = this.idat_offs + 8 + 2 + (i << 16) + (i << 2)
      buffer[off++] = bits
      off = write2lsb(buffer, off, size)
      write2lsb(buffer, off, ~size)

    }

    this.backgroundColor = this.createColor(backgroundColor);

  }

  deflate (): void {

    const { width, height, buffer } = this,
      BASE = 65521,
      NMAX = 5552

    let s1 = 1,
      s2 = 0,
      n = NMAX

    const baseOffset = this.idat_offs + 8 + 2 + 5

    for(let y = 0; y < height; y++)
      for(let x = -1; x < width; x++) {

        const i = y * (width + 1) + x + 1
        s1 += buffer[baseOffset * Math.floor((i / 0xffff) + 1) + i]
        s2 += s1

        if((n-= 1) == 0) {

          s1 %= BASE
          s2 %= BASE
          n = NMAX

        }

      }

    s1 %= BASE
    s2 %= BASE
    write4(buffer, this.idat_offs + this.idat_size - 8, (s2 << 16) | s1)

    lookUpcrc32(buffer, this.ihdr_offs, this.ihdr_size)
    lookUpcrc32(buffer, this.plte_offs, this.plte_size)
    lookUpcrc32(buffer, this.trns_offs, this.trns_size)
    lookUpcrc32(buffer, this.idat_offs, this.idat_size)
    lookUpcrc32(buffer, this.iend_offs, this.iend_size)

  }

  setPixel (x: number, y: number, color: any): void {

    const i = y * (this.width + 1) + x + 1
    this.buffer[this.idat_offs + 8 + 2 + 5 * Math.floor((i / 0xffff) + 1) + i] = color

  }

  index (x: number, y: number): number {

    const i = y * (this.width + 1) + x + 1
    return this.idat_offs + 8 + 2 + 5 * Math.floor((i / 0xffff) + 1) + i

  }

  color (red: number, green: number, blue: number, alpha: number): number {

    alpha = alpha >= 0 ? alpha : 255
    const color: any = ((((((alpha << 8) | red) << 8) | green) << 8) | blue).toString()

    if(this.palette[color] === undefined) {

      if(this.pindex == this.depth)
        return 0

      const ndx = this.plte_offs + 8 + 3 * this.pindex

      this.buffer[ndx] = red
      this.buffer[ndx + 1] = green
      this.buffer[ndx + 2] = blue
      this.buffer[this.trns_offs + 8 + this.pindex] = alpha

      this.palette[color] = this.pindex++

    }

    return this.palette[color]

  }

  getBase64 (): string {

    this.deflate()
    return fromUint8Array(new Uint8Array(this.buffer.buffer))

  }

  getDataURL(): string {

    return 'data:image/png;base64,' + this.getBase64()

  }

  //TODO: conver CSS style colors to rgb
  createColor (rgb: any): number {

    return this.color(rgb.r, rgb.g, rgb.b, Math.round(rgb.a * 255))

  }

  getPixel (x: number, y: number): number {

    const i = y * (this.width + 1) + x + 1
    return this.buffer[this.idat_offs + 8 + 2 + 5 * Math.floor((i / 0xffff) + 1) + i]

  }

}